%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{DFO-GN Documentation}
\date{12 September 2017}
\release{0.1}
\author{Lindon Roberts (Mathematical Institute, University of Oxford)}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


\sphinxstylestrong{Release:} 0.1

\sphinxstylestrong{Date:} 12 September 2017

\sphinxstylestrong{Author:} \sphinxhref{mailto:lindon.roberts@maths.ox.ac.uk}{Lindon Roberts} (Mathematical Institute, University of Oxford)

DFO-GN is a Python package for finding local solutions to \sphinxstylestrong{nonlinear least-squares minimization problems (with optional bound constraints)}, without requiring any derivatives of the objective. DFO-GN stands for Derivative-Free Optimization using Gauss-Newton, and is applicable to problems such as
\begin{itemize}
\item {} 
Parameter estimation/data fitting;

\item {} 
Solving systems of nonlinear equations (including under- and over-determined systems); and

\item {} 
Inverse problems, including data assimilation.

\end{itemize}

DFO-GN is a \sphinxstyleemphasis{derivative-free} algorithm, meaning it does not require any information about the derivative of the objective, nor does it attempt to estimate such information (e.g. by using finite differencing). This means that it is \sphinxstylestrong{particularly useful for solving noisy problems}; i.e. where evaluating the objective function several times for the same input may give different results.

Mathematically, DFO-GN solves
\begin{equation*}
\begin{split}\min_{x\in\mathbb{R}^n}  &\quad  f(x) := \sum_{i=1}^{m}r_{i}(x)^2 \\
\text{s.t.} &\quad  a \leq x \leq b\end{split}
\end{equation*}
where the functions \(r_i(x)\) may be nonlinear and even nonconvex. Full details of the DFO-GN algorithm are given in our paper: C. Cartis and L. Roberts, A Derivative-Free Gauss-Newton Method, \sphinxstyleemphasis{in preparation}, (2017).

DFO-GN is released under the open source GNU General Public License, a copy of which can be found in LICENSE.txt. Please \sphinxhref{http://www.nag.com/content/worldwide-contact-information}{contact NAG} for alternative licensing. It is compatible with both Python 2 and Python 3.

If you have any questions or suggestsions about the code, or have used DFO-GN for an interesting application, we would very much like to hear from you: please contact \sphinxhref{mailto:lindon.roberts@maths.ox.ac.uk}{Lindon Roberts} (\sphinxhref{mailto:lindon.roberts@gmail.com}{alternative email}).


\chapter{Overview}
\label{\detokenize{info:dfo-gn-a-derivative-free-gauss-newton-solver}}\label{\detokenize{info::doc}}\label{\detokenize{info:overview}}

\section{When to use DFO-GN}
\label{\detokenize{info:when-to-use-dfo-gn}}
DFO-GN is designed to solve the nonlinear least-squares minimization problem (with optional bound constraints)
\begin{equation*}
\begin{split}\min_{x\in\mathbb{R}^n}  &\quad  f(x) := \sum_{i=1}^{m}r_{i}(x)^2 \\
\text{s.t.} &\quad  a \leq x \leq b\end{split}
\end{equation*}
We call \(f(x)\) the objective function and \(r_i(x)\) the residual functions (or simply residuals).

DFO-GN is a \sphinxstyleemphasis{derivative-free} optimization algorithm, which means it does not require the user to provide the derivatives of \(f(x)\) or \(r_i(x)\), nor does it attempt to estimate them internally (by using finite differencing, for instance).

There are two main situations when using a derivative-free algorithm (such as DFO-GN) is preferable to a derivative-based algorithm (which is the vast majority of least-squares solvers).

If \sphinxstylestrong{the residuals are noisy}, then calculating or even estimating their derivatives may be impossible (or at least very inaccurate). By noisy, we mean that if we evaluate \(r_i(x)\) multiple times at the same value of \(x\), we get different results. This may happen when a Monte Carlo simulation is used, for instance, or \(r_i(x)\) involves performing a physical experiment.

If \sphinxstylestrong{the residuals are expensive to evaluate}, then estimating derivatives (which requires \(n\) evaluations of each \(r_i(x)\) for every point of interest \(x\)) may be prohibitively expensive. Derivative-free methods are designed to solve the problem with the fewest number of evaluations of the objective as possible.

\sphinxstylestrong{However, if you have provide (or a solver can estimate) derivatives} of \(r_i(x)\), then it is probably a good idea to use one of the many derivative-based solvers (such as \sphinxhref{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least\_squares.html}{one from the SciPy library}).


\section{Parameter Fitting}
\label{\detokenize{info:parameter-fitting}}
A very common problem in many quantitative disciplines is fitting parameters to observed data. Typically, this means that we have developed a model for some proccess, which takes a vector of (known) inputs \(\mathrm{obs}\in\mathbb{R}^N\) and some model parameters \(x=(x_1, \ldots, x_n)\in\mathbb{R}^n\), and computes a (predicted) quantity of interest \(y\in\mathbb{R}\):
\begin{equation*}
\begin{split}y = \mathrm{model}(\mathrm{obs}, x)\end{split}
\end{equation*}
For this model to be useful, we need to determine a suitable choice for the parameters \(x\), which typically cannot be directly observed. A common way of doing this is to calibrate from observed relationships.

Suppose we have some observations of the input-to-output relationship. That is, we have data
\begin{equation*}
\begin{split}(\mathrm{obs}_1, y_1), \ldots, (\mathrm{obs}_m, y_m)\end{split}
\end{equation*}
Then, we try to find the parameters \(x\) which produce the best possible fit to these observations by minimizing the sum-of-squares of the prediction errors:
\begin{equation*}
\begin{split}\min_{x\in\mathbb{R}^n}  \quad  f(x) := \sum_{i=1}^{m}(y_i - \mathrm{model}(\mathrm{obs}_i, x))^2\end{split}
\end{equation*}
which is in the least-squares form required by DFO-GN.

As described above, DFO-GN is a particularly good choice for parameter fitting when the model has noise (e.g. Monte Carlo simulation) or is expensive to evaluate.


\section{Solving Nonlinear Systems of Equations}
\label{\detokenize{info:solving-nonlinear-systems-of-equations}}
Suppose we wish to solve the system of nonlinear equations: find \(x\in\mathbb{R}^n\) satisfying
\begin{equation*}
\begin{split}r_1(x) &= 0 \\
r_2(x) &= 0 \\
&\vdots \\
r_m(x) &= 0\end{split}
\end{equation*}
Such problems can have no solutions, one solution, or many solutions (possibly infinitely many). Often, but certainly not always, the number of solutions depends on whether there are more equations or unknowns: if \(m<n\) we say the system is underdetermined (and there are often multiple solutions), if \(m=n\) we say the system is square (and there is often only one solution), and if \(m>n\) we say the system is overdetermined (and there are often no solutions).

This is not always true \textendash{} there is no solution to the underdetermined system when \(m=1\) and \(n=2\) and we choose \(r_1(x)=\sin(x_1+x_2)-2\), for example.
Similarly, if we take \(n=1\) and \(r_i(x)=i (x-1)(x-2)\), we can make \(m\) as large as we like while keeping \(x=1\) and \(x=2\) as solutions (to the overdetermined system).

If no solution exists, it makes sense to instead search for an \(x\) which approximately satisfies each equation. A common way to do this is to minimize the sum-of-squares of the left-hand-sides:
\begin{equation*}
\begin{split}\min_{x\in\mathbb{R}^n}  \quad  f(x) := \sum_{i=1}^{m}r_i(x)^2\end{split}
\end{equation*}
which is the form required by DFO-GN.

If a solution does exist, then this formulation will also find this (where we will get \(f=0\) at the solution).

\sphinxstylestrong{Which solution?} DFO-GN, and most similar software, will only find one solution to a set of nonlinear equations. Which one it finds is very difficult to predict, and depends very strongly on the point where the solver is started from. Often it finds the closest solution, but there are no guarantees this will be the case. If you need to find all/multiple solutions for your problem, consider techniques such as \sphinxhref{http://www.sciencedirect.com/science/article/pii/0022247X83900550}{deflation}.


\section{Details of the DFO-GN Algorithm}
\label{\detokenize{info:details-of-the-dfo-gn-algorithm}}
DFO-GN is a type of \sphinxstyleemphasis{trust-region} method, a common category of optimization algorithms for nonconvex problems. Given a current estimate of the solution \(x_k\), we compute a model which approximates the objective \(m_k(s)\approx f(x_k+s)\) (for small steps \(s\)), and maintain a value \(\Delta_k>0\) (called the \sphinxstyleemphasis{trust region radius}) which measures the size of \(s\) for which the approximation is good.

At each step, we compute a trial step \(s_k\) designed to make our approximation \(m_k(s)\) small (this task is called the \sphinxstyleemphasis{trust region subproblem}). We evaluate the objective at this new point, and if this provided a good decrease in the objective, we take the step (\(x_{k+1}=x_k+s_k\)), otherwise we stay put (\(x_{k+1}=x_k\)). Based on this information, we choose a new value \(\Delta_{k+1}\), and repeat the process.

In DFO-GN, we construct our approximation \(m_k(s)\) by interpolating a linear approximation for each residual \(r_i(x)\) at several points close to \(x_k\). To make sure our interpolated model is accurate, we need to regularly check that the points are well-spaced, and move them if they aren’t (i.e. improve the geometry of our interpolation points).

A complete description of the DFO-GN algorithm is given in our paper \phantomsection\label{\detokenize{info:id1}}{\hyperref[\detokenize{info:cr2017}]{\sphinxcrossref{{[}CR2017{]}}}}.


\section{References}
\label{\detokenize{info:references}}

\chapter{Installing DFO-GN}
\label{\detokenize{install:installing-dfo-gn}}\label{\detokenize{install::doc}}

\section{Requirements}
\label{\detokenize{install:requirements}}
DFO-GN requires the following software to be installed:
\begin{itemize}
\item {} 
\sphinxhref{http://www.python.org/}{Python 2.7 or Python 3}

\end{itemize}

Additionally, the following python packages should be installed (these will be installed automatically if using \sphinxhref{http://www.pip-installer.org/}{pip}, see {\hyperref[\detokenize{install:installation-using-pip}]{\sphinxcrossref{Installation using pip}}}):
\begin{itemize}
\item {} 
\sphinxhref{http://www.numpy.org/}{NumPy 1.11 or higher}

\item {} 
\sphinxhref{http://www.scipy.org/}{SciPy 0.18 or higher}

\end{itemize}


\section{Installation using pip}
\label{\detokenize{install:installation-using-pip}}
For easy installation, use \sphinxhref{http://www.pip-installer.org/}{pip} as root:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{o}{[}sudo\PYG{o}{]} pip install \PYGZhy{}\PYGZhy{}pre dfogn
\end{sphinxVerbatim}
\end{quote}

If you do not have root privileges or you want to install DFO-GN for your private use, you can use:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pip install \PYGZhy{}\PYGZhy{}pre \PYGZhy{}\PYGZhy{}user dfogn
\end{sphinxVerbatim}
\end{quote}

which will install DFO-GN in your home directory.

Note that if an older install of DFO-GN is present on your system you can use:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{o}{[}sudo\PYG{o}{]} pip install \PYGZhy{}\PYGZhy{}pre \PYGZhy{}\PYGZhy{}upgrade dfogn
\end{sphinxVerbatim}
\end{quote}

to upgrade DFO-GN to the latest version.


\section{Manual installation}
\label{\detokenize{install:manual-installation}}
The source code for DFO-GN is \sphinxhref{https://https://github.com/numericalalgorithmsgroup/dfogn}{available on Github}:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone https://github.com/numericalalgorithmsgroup/dfogn
\PYGZdl{} \PYG{n+nb}{cd} dfogn
\end{sphinxVerbatim}
\end{quote}

or through the \sphinxhref{https://pypi.python.org/pypi/dfogn}{Python Package Index}:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} wget http://pypi.python.org/packages/source/d/dfogn/dfogn\PYGZhy{}X.X.tar.gz
\PYGZdl{} tar \PYGZhy{}xzvf dfogn\PYGZhy{}X.X.tar.gz
\PYGZdl{} \PYG{n+nb}{cd} dfogn\PYGZhy{}X.X
\end{sphinxVerbatim}
\end{quote}

DFO-GN is written in pure Python and requires no compilation. It can be installed using:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{o}{[}sudo\PYG{o}{]} pip install \PYGZhy{}\PYGZhy{}pre .
\end{sphinxVerbatim}
\end{quote}

If you do not have root privileges or you want to install DFO-GN for your private use, you can use:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pip install \PYGZhy{}\PYGZhy{}pre \PYGZhy{}\PYGZhy{}user .
\end{sphinxVerbatim}
\end{quote}

instead.


\section{Testing}
\label{\detokenize{install:testing}}
If you installed DFO-GN manually, you can test your installation by running:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python setup.py \PYG{n+nb}{test}
\end{sphinxVerbatim}
\end{quote}


\section{Uninstallation}
\label{\detokenize{install:uninstallation}}
If DFO-GN was installed using \sphinxhref{http://www.pip-installer.org/}{pip} you can uninstall as follows:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{o}{[}sudo\PYG{o}{]} pip uninstall dfogn
\end{sphinxVerbatim}
\end{quote}

If DFO-GN was installed manually you have to remove the installed files by hand (located in your python site-packages directory).


\chapter{Using DFO-GN}
\label{\detokenize{userguide::doc}}\label{\detokenize{userguide:using-dfo-gn}}
This section describes the main interface to DFO-GN and how to use it.


\section{How to use DFO-GN}
\label{\detokenize{userguide:how-to-use-dfo-gn}}
The main interface to DFO-GN is via the function \sphinxcode{solve}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{dfogn}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{objfun}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

The input \sphinxcode{objfun} is a Python function which takes an input \(x\in\mathbb{R}^n\) and returns the vector of residuals \([r_1(x)\: \cdots \: r_m(x)]\in\mathbb{R}^m\). Both the input and output of \sphinxcode{objfun} must be one-dimensional NumPy arrays (i.e. with \sphinxcode{x.shape == (n,)} and \sphinxcode{objfun(x).shape == (m,)}).

The input \sphinxcode{x0} is the starting point for the solver, and (where possible) should be set to be the best available estimate of the true solution \(x_{min}\in\mathbb{R}^n\). It should be specified as a one-dimensional NumPy array (i.e. with \sphinxcode{x0.shape == (n,)}).
As DFO-GN is a local solver, providing different values for \sphinxcode{x0} may cause it to return different solutions, with possibly different objective values.


\section{Outputs}
\label{\detokenize{userguide:outputs}}
The output of \sphinxcode{dfogn.solve} is an object \sphinxcode{soln} containing:
\begin{itemize}
\item {} 
\sphinxcode{soln.x} - an estimate of the solution, \(x_{min}\in\mathbb{R}^n\), a one-dimensional NumPy array.

\item {} 
\sphinxcode{soln.resid} - the vector of residuals at the calculated solution \([r_1(x_{min})\: \cdots \: r_m(x_{min})]\in\mathbb{R}^m\)

\item {} 
\sphinxcode{soln.f} - the objective value at the calculated solution, \(f(x_{min})\), a Float.

\item {} 
\sphinxcode{soln.jacobian} - an estimate of the \(m\times n\) Jacobian matrix of first derivatives at the calculated solution \(J_{i,j} \approx \partial r_i(x_{min})/\partial x_j\), a two-dimensional NumPy array.

\item {} 
\sphinxcode{soln.nf} - the number of evaluations of \sphinxcode{objfun} that the algorithm needed, an Integer.

\item {} 
\sphinxcode{soln.flag} - an exit flag, which can take one of several values (listed below), an Integer.

\item {} 
\sphinxcode{soln.msg} - a description of why the algorithm finished, a String.

\end{itemize}

The possible values of \sphinxcode{flag} are defined by the following variables, also defined in the \sphinxcode{soln} object:
\begin{itemize}
\item {} 
\sphinxcode{soln.EXIT\_SUCCESS = 0} - DFO-GN terminated successfully (the objective value or trust region radius are sufficiently small).

\item {} 
\sphinxcode{soln.EXIT\_INPUT\_ERROR = 1} - error in the inputs.

\item {} 
\sphinxcode{soln.EXIT\_MAXFUN\_WARNING = 2} - maximum allowed objective evaluations reached.

\item {} 
\sphinxcode{soln.EXIT\_TR\_INCREASE\_ERROR = 3} - error occurred when solving the trust region subproblem.

\item {} 
\sphinxcode{soln.EXIT\_LINALG\_ERROR = 4} - linear algebra error, e.g. the interpolation points produced a singular linear system.

\item {} 
\sphinxcode{soln.EXIT\_ALTMOV\_MEMORY\_ERROR = 5} - error occurred when determining a geometry-improving step.

\end{itemize}

For more information about how to interpret these descriptions, see the algorithm details section in {\hyperref[\detokenize{info::doc}]{\sphinxcrossref{\DUrole{doc}{Overview}}}}. If you encounter any of the last 4 conditions, first check to see if the output value is sufficient for your requirements, otherwise consider changing \sphinxcode{x0} or the optional parameter \sphinxcode{rhobeg} (see below).

As variables are defined in the \sphinxcode{soln} objected, they can be accessed with, for example
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{flag} \PYG{o}{==} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{EXIT\PYGZus{}SUCCESS}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Success!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\section{Optional Arguments}
\label{\detokenize{userguide:optional-arguments}}
The \sphinxcode{solve} function has several optional arguments which the user may provide:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dfogn}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{objfun}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{lower}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{upper}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{maxfun}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{,}
            \PYG{n}{rhobeg}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{rhoend}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

These arguments are:
\begin{itemize}
\item {} 
\sphinxcode{lower} - the vector \(a\) of lower bounds on \(x\) (default is \(a_i=-10^{20}\)).

\item {} 
\sphinxcode{upper} - the vector \(b\) of upper bounds on \(x\) (default is \(b_i=10^{20}\)).

\item {} 
\sphinxcode{maxfun} - the maximum number of objective evaluations the algorithm may request (default is 1000).

\item {} 
\sphinxcode{rhobeg} - the initial value of the trust region radius (default is \(0.1\max(\|x_0\|_{\infty}, 1)\)).

\item {} 
\sphinxcode{rhoend} - minimum allowed value of trust region radius, which determines when a successful termination occurs (default is \(10^{-8}\)).

\end{itemize}

There is a tradeoff when choosing the value of \sphinxcode{rhobeg}: a large value allows the algorithm to progress to a solution quicker, but there is a greater risk that it tries points which do not reduce the objective. Similarly, a small value means a greater chance of reducing the objective, but potentially making slower progress towards the final solution.

The value of \sphinxcode{rhoend} determines the level of accuracy desired in the solution \sphinxcode{xmin} (smaller values give higher accuracy, but DFO-GN will take longer to finish).

The requirements on the inputs are:
\begin{itemize}
\item {} 
Each entry of \sphinxcode{lower} must be strictly below the corresponding entry of \sphinxcode{upper}, with a gap of at least twice \sphinxcode{rhobeg};

\item {} 
Both \sphinxcode{rhobeg} and \sphinxcode{rhoend} must be strictly positive, with \sphinxcode{rhoend} being the smaller one; and

\item {} 
The value \sphinxcode{maxfun} must be strictly positive, and generally should be above \sphinxcode{len(x)+1} (which is the initial setup requirement).

\end{itemize}


\section{A Simple Example}
\label{\detokenize{userguide:a-simple-example}}
Suppose we wish to minimize the \sphinxhref{https://en.wikipedia.org/wiki/Rosenbrock\_function}{Rosenbrock function} (a common test problem):
\begin{equation*}
\begin{split}\min_{(x_1,x_2)\in\mathbb{R}^2}  &\quad  100(x_2-x_1^2)^2 + (1-x_1)^2 \\\end{split}
\end{equation*}
This function has only one local minimum \(f(x_{min})=0\) at \(x_{min}=(1,1)\). We can write this as a least-squares problem as:
\begin{equation*}
\begin{split}\min_{(x_1,x_2)\in\mathbb{R}^2}  &\quad  [10(x_2-x_1^2)]^2 + [1-x_1]^2 \\\end{split}
\end{equation*}
A commonly-used starting point for testing purposes is \(x_0=(-1.2,1)\). The following script shows how to solve this problem using DFO-GN:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} DFO\PYGZhy{}GN example: minimize the Rosenbrock function}
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{dfogn}

\PYG{c+c1}{\PYGZsh{} Define the objective function}
\PYG{k}{def} \PYG{n+nf}{rosenbrock}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{10.0} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define the starting point}
\PYG{n}{x0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Call DFO\PYGZhy{}GN}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{dfogn}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{rosenbrock}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Display output}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ *** DFO\PYGZhy{}GN results *** }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Solution xmin = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Objective value f(xmin) = }\PYG{l+s+si}{\PYGZpc{}.10g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{f}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Needed }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{ objective evaluations}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{nf}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Residual vector = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{resid}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Approximate Jacobian = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{jacobian}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exit flag = }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{flag}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{msg}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

The output of this script is
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 *** DFO\PYGZhy{}GN results ***
Solution xmin = [ 1.  1.]
Objective value f(xmin) = 1.268313548e\PYGZhy{}17
Needed 50 objective evaluations
Residual vector = [ \PYGZhy{}3.56133900e\PYGZhy{}09   0.00000000e+00]
Approximate Jacobian = [[ \PYGZhy{}2.00012196e+01   1.00002643e+01]
 [ \PYGZhy{}1.00000000e+00   3.21018592e\PYGZhy{}13]]
Exit flag = 0
Success: Objective is sufficiently small
\end{sphinxVerbatim}
\end{quote}

Note in particular that the Jacobian is not quite correct - the bottom-right entry should be exactly zero for all \(x\), for instance.


\section{Adding Bounds and More Output}
\label{\detokenize{userguide:adding-bounds-and-more-output}}
We can extend the above script to add constraints. To do this, we can add the lines
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define bound constraints (a \PYGZlt{}= x \PYGZlt{}= b)}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{10.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{10.0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{l+m+mf}{0.85}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Call DFO\PYGZhy{}GN (with bounds)}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{dfogn}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{rosenbrock}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{lower}\PYG{o}{=}\PYG{n}{a}\PYG{p}{,} \PYG{n}{upper}\PYG{o}{=}\PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

DFO-GN correctly finds the solution to the constrained problem:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Solution xmin = [ 0.9   0.81]
Objective value f(xmin) = 0.01
Needed 44 objective evaluations
Residual vector = [ \PYGZhy{}2.01451078e\PYGZhy{}10   1.00000000e\PYGZhy{}01]
Approximate Jacobian = [[ \PYGZhy{}1.79999994e+01   1.00000004e+01]
 [ \PYGZhy{}9.99999973e\PYGZhy{}01   2.01450058e\PYGZhy{}08]]
Exit flag = 0
Success: rho has reached rhoend
\end{sphinxVerbatim}
\end{quote}

However, we also get a warning that our starting point was outside of the bounds:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
RuntimeWarning: Some entries of x0 above upper bound, adjusting
\end{sphinxVerbatim}
\end{quote}

DFO-GN automatically fixes this, and moves \(x_0\) to a point within the bounds, in this case \(x_0=(-1.2, 0.85)\).

We can also get DFO-GN to print out more detailed information about its progress using the \sphinxhref{https://docs.python.org/3/library/logging.html}{logging} module. To do this, we need to add the following lines:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{n}{logging}\PYG{o}{.}\PYG{n}{basicConfig}\PYG{p}{(}\PYG{n}{level}\PYG{o}{=}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{INFO}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}(message)s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} ... (call dfogn.solve)}
\end{sphinxVerbatim}
\end{quote}

And we can now see each evaluation of \sphinxcode{objfun}:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Function eval 1 has f = 39.65 at x = [\PYGZhy{}1.2   0.85]
Function eval 2 has f = 14.337296 at x = [\PYGZhy{}1.08  0.85]
...
Function eval 43 has f = 0.010000000899913 at x = [ 0.9         0.80999999]
Function eval 44 has f = 0.01 at x = [ 0.9   0.81]
\end{sphinxVerbatim}
\end{quote}

If we wanted to save this output to a file, we could replace the above call to \sphinxcode{logging.basicConfig()} with
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{logging}\PYG{o}{.}\PYG{n}{basicConfig}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myfile.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{level}\PYG{o}{=}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{INFO}\PYG{p}{,}
                    \PYG{n}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}(message)s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{filemode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\section{Example: Noisy Objective Evaluation}
\label{\detokenize{userguide:example-noisy-objective-evaluation}}
As described in {\hyperref[\detokenize{info::doc}]{\sphinxcrossref{\DUrole{doc}{Overview}}}}, derivative-free algorithms such as DFO-GN are particularly useful when \sphinxcode{objfun} has noise. Let’s modify the previous example to include random noise in our objective evaluation, and compare it to a derivative-based solver:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} DFO\PYGZhy{}GN example: minimize the Rosenbrock function}
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{dfogn}

\PYG{c+c1}{\PYGZsh{} Define the objective function}
\PYG{k}{def} \PYG{n+nf}{rosenbrock}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{10.0} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Modified objective function: add 1\PYGZpc{} Gaussian noise}
\PYG{k}{def} \PYG{n+nf}{rosenbrock\PYGZus{}noisy}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{rosenbrock}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{l+m+mf}{1e\PYGZhy{}2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define the starting point}
\PYG{n}{x0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set random seed (for reproducibility)}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Demonstrate noise in function evaluation:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{objfun(x0) = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{rosenbrock\PYGZus{}noisy}\PYG{p}{(}\PYG{n}{x0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Call DFO\PYGZhy{}GN}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{dfogn}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{rosenbrock\PYGZus{}noisy}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Display output}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ *** DFO\PYGZhy{}GN results *** }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Solution xmin = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Objective value f(xmin) = }\PYG{l+s+si}{\PYGZpc{}.10g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{f}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Needed }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{ objective evaluations}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{nf}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Residual vector = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{resid}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Approximate Jacobian = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{jacobian}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exit flag = }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{flag}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{msg}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Compare with a derivative\PYGZhy{}based solver}
\PYG{k+kn}{import} \PYG{n+nn}{scipy.optimize} \PYG{k+kn}{as} \PYG{n+nn}{opt}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{least\PYGZus{}squares}\PYG{p}{(}\PYG{n}{rosenbrock\PYGZus{}noisy}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{)}

\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ *** SciPy results *** }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Solution xmin = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Objective value f(xmin) = }\PYG{l+s+si}{\PYGZpc{}.10g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{cost}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Needed }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{ objective evaluations}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{nfev}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exit flag = }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{status}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{message}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

The output of this is:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Demonstrate noise in function evaluation:
objfun(x0) = [\PYGZhy{}4.4776183   2.20880346]
objfun(x0) = [\PYGZhy{}4.44306447  2.24929965]
objfun(x0) = [\PYGZhy{}4.48217255  2.17849989]
objfun(x0) = [\PYGZhy{}4.44180389  2.19667014]
objfun(x0) = [\PYGZhy{}4.39545837  2.20903317]

 *** DFO\PYGZhy{}GN results ***
Solution xmin = [ 1.  1.]
Objective value f(xmin) = 4.658911493e\PYGZhy{}15
Needed 56 objective evaluations
Residual vector = [ \PYGZhy{}6.82177042e\PYGZhy{}08  \PYGZhy{}2.29266787e\PYGZhy{}09]
Approximate Jacobian = [[ \PYGZhy{}2.01345344e+01   1.01261457e+01]
 [ \PYGZhy{}1.00035048e+00  \PYGZhy{}5.99847638e\PYGZhy{}03]]
Exit flag = 0
Success: Objective is sufficiently small

 *** SciPy results ***
Solution xmin = [\PYGZhy{}1.20000033  1.00000016]
Objective value f(xmin) = 23.66957245
Needed 6 objective evaluations
Exit flag = 3
{}`xtol{}` termination condition is satisfied.
\end{sphinxVerbatim}
\end{quote}

DFO-GN is able to find the solution with only 6 more function evaluations than in the noise-free case. However SciPy’s derivative-based solver, which has no trouble solving the noise-free problem, is unable to make any progress.


\section{Example: Parameter Estimation/Data Fitting}
\label{\detokenize{userguide:example-parameter-estimation-data-fitting}}
Next, we show a short example of using DFO-GN to solve a parameter estimation problem (taken from \sphinxhref{https://uk.mathworks.com/help/optim/ug/lsqcurvefit.html\#examples}{here}). Given some observations \((t_i,y_i)\), we wish to calibrate parameters \(x=(x_1,x_2)\) in the exponential decay model
\begin{equation*}
\begin{split}y(t) = x_1 \exp(x_2 t)\end{split}
\end{equation*}
The code for this is:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} DFO\PYGZhy{}GN example: data fitting problem}
\PYG{c+c1}{\PYGZsh{} Originally from:}
\PYG{c+c1}{\PYGZsh{} https://uk.mathworks.com/help/optim/ug/lsqcurvefit.html}
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{dfogn}

\PYG{c+c1}{\PYGZsh{} Observations}
\PYG{n}{tdata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{13.8}\PYG{p}{,} \PYG{l+m+mf}{19.8}\PYG{p}{,} \PYG{l+m+mf}{24.1}\PYG{p}{,} \PYG{l+m+mf}{28.2}\PYG{p}{,} \PYG{l+m+mf}{35.2}\PYG{p}{,}
                  \PYG{l+m+mf}{60.3}\PYG{p}{,} \PYG{l+m+mf}{74.6}\PYG{p}{,} \PYG{l+m+mf}{81.3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ydata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{455.2}\PYG{p}{,} \PYG{l+m+mf}{428.6}\PYG{p}{,} \PYG{l+m+mf}{124.1}\PYG{p}{,} \PYG{l+m+mf}{67.3}\PYG{p}{,} \PYG{l+m+mf}{43.2}\PYG{p}{,} \PYG{l+m+mf}{28.1}\PYG{p}{,} \PYG{l+m+mf}{13.1}\PYG{p}{,}
                  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Model is y(t) = x[0] * exp(x[1] * t)}
\PYG{k}{def} \PYG{n+nf}{prediction\PYGZus{}error}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{ydata} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{tdata}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define the starting point}
\PYG{n}{x0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{100.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} We expect exponential decay: set upper bound x[1] \PYGZlt{}= 0}
\PYG{n}{upper} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1e20}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Call DFO\PYGZhy{}GN}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{dfogn}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{prediction\PYGZus{}error}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{upper}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Display output}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ *** DFO\PYGZhy{}GN results *** }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Solution xmin = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Objective value f(xmin) = }\PYG{l+s+si}{\PYGZpc{}.10g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{f}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Needed }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{ objective evaluations}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{nf}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exit flag = }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{flag}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{msg}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

The output of this is (noting that DFO-GN moves \(x_0\) to be far away enough from the upper bound)
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
RuntimeWarning: Some entries of x0 too close to upper bound, adjusting
 *** DFO\PYGZhy{}GN results ***
Solution xmin = [  4.98830861e+02  \PYGZhy{}1.01256863e\PYGZhy{}01]
Objective value f(xmin) = 9.504886892
Needed 107 objective evaluations
Exit flag = 0
Success: rho has reached rhoend
\end{sphinxVerbatim}
\end{quote}

This produces a good fit to the observations.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.750\linewidth]{{data_fitting}.png}\hspace*{\fill}}


\section{Example: Solving a Nonlinear System of Equations}
\label{\detokenize{userguide:example-solving-a-nonlinear-system-of-equations}}
Lastly, we give an example of using DFO-GN to solve a nonlinear system of equations (taken from \sphinxhref{http://support.sas.com/documentation/cdl/en/imlug/66112/HTML/default/viewer.htm\#imlug\_genstatexpls\_sect004.htm}{here}). We wish to solve the following set of equations
\begin{equation*}
\begin{split}x_1 + x_2 - x_1 x_2 + 2 &= 0, \\
x_1 \exp(-x_2) - 1 &= 0.\end{split}
\end{equation*}
The code for this is:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} DFO\PYGZhy{}GN example: Solving a nonlinear system of equations}
\PYG{c+c1}{\PYGZsh{} http://support.sas.com/documentation/cdl/en/imlug/66112/HTML/default/viewer.htm\PYGZsh{}imlug\PYGZus{}genstatexpls\PYGZus{}sect004.htm}

\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{dfogn}

\PYG{c+c1}{\PYGZsh{} Want to solve:}
\PYG{c+c1}{\PYGZsh{}   x1 + x2 \PYGZhy{} x1*x2 + 2 = 0}
\PYG{c+c1}{\PYGZsh{}   x1 * exp(\PYGZhy{}x2) \PYGZhy{} 1   = 0}
\PYG{k}{def} \PYG{n+nf}{nonlinear\PYGZus{}system}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{,}
                     \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Warning: if there are multiple solutions, which one}
\PYG{c+c1}{\PYGZsh{}          DFO\PYGZhy{}GN returns will likely depend on x0!}
\PYG{n}{x0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{soln} \PYG{o}{=} \PYG{n}{dfogn}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{nonlinear\PYGZus{}system}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Display output}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ *** DFO\PYGZhy{}GN results *** }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Solution xmin = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Objective value f(xmin) = }\PYG{l+s+si}{\PYGZpc{}.10g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{f}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Needed }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{ objective evaluations}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{nf}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Residual vector = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{resid}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exit flag = }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{flag}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{msg}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

The output of this is
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 *** DFO\PYGZhy{}GN results ***
Solution xmin = [ 0.09777309 \PYGZhy{}2.32510588]
Objective value f(xmin) = 2.048743163e\PYGZhy{}24
Needed 24 objective evaluations
Residual vector = [  1.23900890e\PYGZhy{}13   1.42597045e\PYGZhy{}12]
Exit flag = 0
Success: Objective is sufficiently small
\end{sphinxVerbatim}
\end{quote}

Here, we see that both entries of the residual vector are very small, so both equations have been solved to high accuracy.


\chapter{Acknowledgements}
\label{\detokenize{index:acknowledgements}}
This software was developed under the supervision of \sphinxhref{https://www.maths.ox.ac.uk/people/coralia.cartis}{Coralia Cartis} (Mathematical Institute, University of Oxford), and was supported by the EPSRC Centre For Doctoral Training in \sphinxhref{https://www.maths.ox.ac.uk/study-here/postgraduate-study/industrially-focused-mathematical-modelling-epsrc-cdt}{Industrially Focused Mathematical Modelling} (EP/L015803/1) at the University of Oxford’s Mathematical Institute, in collaboration with the \sphinxhref{http://www.nag.com/}{Numerical Algorithms Group}.

DFO-GN was developed using techniques from DFBOLS (\sphinxhref{https://doi.org/10.1137/09075531X}{Zhang, Conn \& Scheinberg, 2010}) and BOBYQA (\sphinxhref{http://mat.uc.pt/~zhang/software.html}{Powell, 2009}).
The structure of this documentation is from \sphinxhref{http://pythonhosted.org/oBB/}{oBB} by Jari Fowkes.

\begin{sphinxthebibliography}{CR2017}
\bibitem[CR2017]{\detokenize{CR2017}}{\phantomsection\label{\detokenize{info:cr2017}} 
Cartis, C. and Roberts, L., A Derivative-Free Gauss-Newton Method, \sphinxstyleemphasis{in preparation} (2017).
}
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}